import { render, screen, fireEvent, waitFor } from '@testing-library/react';import '@testing-library/jest-dom';import App from './App';import Dashboard from './components/Dashboard';import ErrorBoundary from './components/ErrorBoundary';import { useNotifications } from './components/NotificationSystem';// Mock Firebasejest.mock('./firebase', () => ({  auth: {    onAuthStateChanged: jest.fn((callback) => {      callback(null); // Simulate no user      return jest.fn(); // Return unsubscribe function    })  },  db: {}}));// Mock analyticsjest.mock('./utils/analytics', () => ({  __esModule: true,  default: {    getAnalytics: jest.fn(() => Promise.resolve({}))  },  trackEvent: jest.fn(() => Promise.resolve()),  trackScan: jest.fn(() => Promise.resolve()),  getDeviceId: jest.fn(() => 'test-device-id')}));// Mock useUser hookjest.mock('./hooks/useUser', () => ({  useUser: () => ({    user: null,    isPremium: false,    canPerformScan: () => true,    getRemainingScans: () => 3,    incrementScanCount: jest.fn(),    isLoading: false,    userProfile: null  })}));// Mock notification systemconst mockNotifications = {  showSuccess: jest.fn(),  showError: jest.fn(),  showWarning: jest.fn(),  showInfo: jest.fn(),  notifications: [],  addNotification: jest.fn(),  removeNotification: jest.fn()};jest.mock('./components/NotificationSystem', () => ({  __esModule: true,  default: ({ children }) => <>{children}</>,  useNotifications: () => mockNotifications}));// Mock useAutoLogoutjest.mock('./utils/autoLogout', () => ({  useAutoLogout: jest.fn()}));describe('Naturinex App', () => {  test('renders without crashing', () => {    render(<App />);    // App should render without throwing errors  });  test('renders dashboard when not loading', () => {    render(<App />);    expect(screen.getByText('Naturinex')).toBeInTheDocument();  });  test('error boundary catches and displays errors', () => {    const ThrowError = ({ shouldThrow }) => {      if (shouldThrow) {        throw new Error('Test error');      }      return <div>No error</div>;    };    const { rerender } = render(      <ErrorBoundary>        <ThrowError shouldThrow={false} />      </ErrorBoundary>    );    expect(screen.getByText('No error')).toBeInTheDocument();    rerender(      <ErrorBoundary>        <ThrowError shouldThrow={true} />      </ErrorBoundary>    );    expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument();  });});describe('Dashboard Component', () => {  beforeEach(() => {    jest.clearAllMocks();  });  test('renders medication input field', () => {    render(<Dashboard />);    expect(screen.getByPlaceholderText(/Enter medication name/i)).toBeInTheDocument();  });  test('disables scan button when medication name is empty', () => {    render(<Dashboard />);    const scanButton = screen.getByText(/Analyze Medication/i);    expect(scanButton).toBeDisabled();  });  test('shows warning for invalid medication name', async () => {    render(<Dashboard />);    const input = screen.getByPlaceholderText(/Enter medication name/i);    const scanButton = screen.getByText(/Analyze Medication/i);    // Enter a single character (less than minimum required)    fireEvent.change(input, { target: { value: 'a' } });    fireEvent.click(scanButton);    await waitFor(() => {      expect(mockNotifications.showWarning).toHaveBeenCalledWith(        'Medication name must be at least 2 characters',        'Invalid Input'      );    });  });});describe('Notification System', () => {  test('useNotifications hook provides notification methods', () => {    let notificationHook;    function TestComponent() {      notificationHook = useNotifications();      return <div>Test</div>;    }    render(<TestComponent />);    expect(typeof notificationHook.showSuccess).toBe('function');    expect(typeof notificationHook.showError).toBe('function');    expect(typeof notificationHook.showWarning).toBe('function');    expect(typeof notificationHook.showInfo).toBe('function');    expect(Array.isArray(notificationHook.notifications)).toBe(true);  });});