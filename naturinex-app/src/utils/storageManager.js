// üóÑÔ∏è Storage Management Utility// Handle scan storage time limits and cleanup for different user tiersimport { db } from '../firebase';import { collection, query, where, getDocs, deleteDoc } from 'firebase/firestore';// import { setDoc } from 'firebase/firestore'; // Commented out to fix warningclass StorageManager {  constructor() {    this.storageLimits = {      free: 3,           // 3-day storage      basic: 30,         // 30-day storage        premium: 0,        // Permanent (0 = no limit)      professional: 0    // Permanent (0 = no limit)    };  }  // Get user's storage limit based on their tier  getUserStorageLimit(userTier) {    return this.storageLimits[userTier] || this.storageLimits.basic;  }  // Clean up expired scans for a user  async cleanupExpiredScans(userId, userTier = 'registered') {    try {      const storageLimit = this.getUserStorageLimit(userTier);        // Premium/Professional users have permanent storage      if (storageLimit === 0) {        `);        return { deleted: 0, kept: 'all' };      }      const cutoffDate = new Date();      cutoffDate.setDate(cutoffDate.getDate() - storageLimit);      // Query expired scans      const scansRef = collection(db, `users/${userId}/scans`);      const expiredQuery = query(        scansRef,        where('timestamp', '<', cutoffDate)      );      const expiredScans = await getDocs(expiredQuery);      let deletedCount = 0;      // Delete expired scans      for (const scanDoc of expiredScans.docs) {        await deleteDoc(scanDoc.ref);        deletedCount++;      }      `);      return { deleted: deletedCount, cutoffDate };    } catch (error) {      console.error('Error cleaning up expired scans:', error);      return { error: error.message };    }  }  // Check if user is approaching storage limit  async checkStorageWarning(userId, userTier = 'registered') {    try {      const storageLimit = this.getUserStorageLimit(userTier);      // Premium/Professional users don't need warnings      if (storageLimit === 0) return null;      const warningDate = new Date();      warningDate.setDate(warningDate.getDate() - (storageLimit - 7)); // 7 days before expiry      const scansRef = collection(db, `users/${userId}/scans`);      const warningQuery = query(        scansRef,        where('timestamp', '<', warningDate)      );      const warningScan = await getDocs(warningQuery);      if (!warningScan.empty) {        return {          message: `${warningScan.size} scans will be deleted in 7 days. Upgrade to Premium for permanent storage!`,          count: warningScan.size,          daysLeft: 7        };      }      return null;    } catch (error) {      console.error('Error checking storage warning:', error);      return null;    }  }  // Add watermark to free tier results  addWatermark(suggestions, userTier) {    if (userTier === 'free') {      return `${suggestions}\n\n---\nüè∑Ô∏è Generated by Naturinex Free - Sign up for ad-free results and permanent storage!`;    }    return suggestions;  }  // Get scan quota for user tier  getScanQuota(userTier) {    const quotas = {      free: { daily: 2, monthly: 10 },           // 2 per day for free trial      beta: { daily: 20, monthly: 100 },         // GENEROUS limits for beta testers      basic: { daily: 10, monthly: 10 },         // $7.99/month - 10 scans per month      premium: { daily: 10, monthly: 50 },       // $14.99/month - 50 scans per month        professional: { daily: 20, monthly: 200 }  // $39.99/month - 200 scans per month    };    return quotas[userTier] || quotas.free;  }  // Check if user can perform scan  async canUserScan(userId, userTier, currentScans) {    const quota = this.getScanQuota(userTier);    // Check monthly limit    if (currentScans.monthly >= quota.monthly) {      return {        allowed: false,        reason: 'monthly_limit',        limit: quota.monthly,        current: currentScans.monthly      };    }    // Check daily limit    if (currentScans.daily >= quota.daily) {      return {        allowed: false,        reason: 'daily_limit',         limit: quota.daily,        current: currentScans.daily      };    }    return { allowed: true };  }  // Auto-cleanup job - should be run daily  async runDailyCleanup() {    try {      // Get all users who need cleanup (registered tier)      const usersRef = collection(db, 'users');      const registeredUsers = query(        usersRef,        where('tier', 'in', ['registered', 'free'])      );      const users = await getDocs(registeredUsers);      let totalCleaned = 0;      for (const userDoc of users.docs) {        const userData = userDoc.data();        const tier = userData.tier || 'registered';        const result = await this.cleanupExpiredScans(userDoc.id, tier);        if (result.deleted) {          totalCleaned += result.deleted;        }      }      return { success: true, totalCleaned };    } catch (error) {      console.error('‚ùå Daily cleanup failed:', error);      return { success: false, error: error.message };    }  }  // Get storage stats for analytics  async getStorageStats() {    try {      const stats = {        totalScans: 0,        scansByTier: { free: 0, registered: 0, premium: 0, pro: 0 },        storageUsed: 0,        expiredScans: 0      };      // This would require aggregation queries or cloud functions      // For now, return placeholder stats      return stats;    } catch (error) {      console.error('Error getting storage stats:', error);      return null;    }  }}// Export singleton instanceconst storageManager = new StorageManager();export default storageManager;// Convenience functionsexport const cleanupExpiredScans = (userId, userTier) =>   storageManager.cleanupExpiredScans(userId, userTier);export const checkStorageWarning = (userId, userTier) =>   storageManager.checkStorageWarning(userId, userTier);export const addWatermark = (suggestions, userTier) =>   storageManager.addWatermark(suggestions, userTier);export const getScanQuota = (userTier) =>   storageManager.getScanQuota(userTier);export const canUserScan = (userId, userTier, currentScans) =>   storageManager.canUserScan(userId, userTier, currentScans);