// üóÑÔ∏è Storage Management Utility
// Handle scan storage time limits and cleanup for different user tiers

import { db } from '../firebase';
import { collection, query, where, getDocs, deleteDoc, setDoc } from 'firebase/firestore';

class StorageManager {  constructor() {
    this.storageLimits = {
      free: 3,           // 3-day storage
      basic: 30,         // 30-day storage  
      premium: 0,        // Permanent (0 = no limit)
      professional: 0    // Permanent (0 = no limit)
    };
  }
  // Get user's storage limit based on their tier
  getUserStorageLimit(userTier) {
    return this.storageLimits[userTier] || this.storageLimits.basic;
  }

  // Clean up expired scans for a user
  async cleanupExpiredScans(userId, userTier = 'registered') {
    try {
      const storageLimit = this.getUserStorageLimit(userTier);
        // Premium/Professional users have permanent storage
      if (storageLimit === 0) {
        console.log(`${userTier} user - no cleanup needed (permanent storage)`);
        return { deleted: 0, kept: 'all' };
      }

      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - storageLimit);

      // Query expired scans
      const scansRef = collection(db, `users/${userId}/scans`);
      const expiredQuery = query(
        scansRef,
        where('timestamp', '<', cutoffDate)
      );

      const expiredScans = await getDocs(expiredQuery);
      let deletedCount = 0;

      // Delete expired scans
      for (const scanDoc of expiredScans.docs) {
        await deleteDoc(scanDoc.ref);
        deletedCount++;
      }

      console.log(`Cleaned up ${deletedCount} expired scans for user ${userId} (${userTier} tier)`);
      return { deleted: deletedCount, cutoffDate };

    } catch (error) {
      console.error('Error cleaning up expired scans:', error);
      return { error: error.message };
    }
  }

  // Check if user is approaching storage limit
  async checkStorageWarning(userId, userTier = 'registered') {
    try {      const storageLimit = this.getUserStorageLimit(userTier);
      
      // Premium/Professional users don't need warnings
      if (storageLimit === 0) return null;

      const warningDate = new Date();
      warningDate.setDate(warningDate.getDate() - (storageLimit - 7)); // 7 days before expiry

      const scansRef = collection(db, `users/${userId}/scans`);
      const warningQuery = query(
        scansRef,
        where('timestamp', '<', warningDate)
      );

      const warningScan = await getDocs(warningQuery);
      
      if (!warningScan.empty) {
        return {
          message: `${warningScan.size} scans will be deleted in 7 days. Upgrade to Premium for permanent storage!`,
          count: warningScan.size,
          daysLeft: 7
        };
      }

      return null;

    } catch (error) {
      console.error('Error checking storage warning:', error);
      return null;
    }
  }

  // Add watermark to free tier results
  addWatermark(suggestions, userTier) {
    if (userTier === 'free') {
      return `${suggestions}\n\n---\nüè∑Ô∏è Generated by MediScan Free - Sign up for ad-free results and permanent storage!`;
    }
    return suggestions;
  }
  // Get scan quota for user tier
  getScanQuota(userTier) {
    const quotas = {
      free: { daily: 1, monthly: 30 },           // 1 per day (forces daily engagement)
      basic: { daily: 10, monthly: 10 },         // $7.99/month - 10 scans per month
      premium: { daily: 10, monthly: 50 },       // $14.99/month - 50 scans per month  
      professional: { daily: 20, monthly: 200 }  // $39.99/month - 200 scans per month
    };
    
    return quotas[userTier] || quotas.basic;
  }

  // Check if user can perform scan
  async canUserScan(userId, userTier, currentScans) {
    const quota = this.getScanQuota(userTier);
    
    // Check monthly limit
    if (currentScans.monthly >= quota.monthly) {
      return {
        allowed: false,
        reason: 'monthly_limit',
        limit: quota.monthly,
        current: currentScans.monthly
      };
    }

    // Check daily limit
    if (currentScans.daily >= quota.daily) {
      return {
        allowed: false,
        reason: 'daily_limit', 
        limit: quota.daily,
        current: currentScans.daily
      };
    }

    return { allowed: true };
  }

  // Auto-cleanup job - should be run daily
  async runDailyCleanup() {
    try {
      console.log('üßπ Starting daily storage cleanup...');
      
      // Get all users who need cleanup (registered tier)
      const usersRef = collection(db, 'users');
      const registeredUsers = query(
        usersRef,
        where('tier', 'in', ['registered', 'free'])
      );

      const users = await getDocs(registeredUsers);
      let totalCleaned = 0;

      for (const userDoc of users.docs) {
        const userData = userDoc.data();
        const tier = userData.tier || 'registered';
        
        const result = await this.cleanupExpiredScans(userDoc.id, tier);
        if (result.deleted) {
          totalCleaned += result.deleted;
        }
      }

      console.log(`‚úÖ Daily cleanup complete. Cleaned ${totalCleaned} expired scans.`);
      return { success: true, totalCleaned };

    } catch (error) {
      console.error('‚ùå Daily cleanup failed:', error);
      return { success: false, error: error.message };
    }
  }

  // Get storage stats for analytics
  async getStorageStats() {
    try {
      const stats = {
        totalScans: 0,
        scansByTier: { free: 0, registered: 0, premium: 0, pro: 0 },
        storageUsed: 0,
        expiredScans: 0
      };

      // This would require aggregation queries or cloud functions
      // For now, return placeholder stats
      return stats;

    } catch (error) {
      console.error('Error getting storage stats:', error);
      return null;
    }
  }
}

// Export singleton instance
const storageManager = new StorageManager();
export default storageManager;

// Convenience functions
export const cleanupExpiredScans = (userId, userTier) => 
  storageManager.cleanupExpiredScans(userId, userTier);

export const checkStorageWarning = (userId, userTier) => 
  storageManager.checkStorageWarning(userId, userTier);

export const addWatermark = (suggestions, userTier) => 
  storageManager.addWatermark(suggestions, userTier);

export const getScanQuota = (userTier) => 
  storageManager.getScanQuota(userTier);

export const canUserScan = (userId, userTier, currentScans) => 
  storageManager.canUserScan(userId, userTier, currentScans);
